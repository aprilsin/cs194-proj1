<html>
<head>
<style>
h1 {text-align: center;}
div {text-align: center;}
img {max-width:400px;}
</style>
</head>
<body>

<h1> Images of the Russian Empire:
Colorizing the Prokudin-Gorskii photo collection</h1>

<h2> Project Overview </h2>
<p> 
	In 1907, Sergei Mikhailovich Prokudin-Gorskii (1863-1944) [Сергей Михайлович Прокудин-Горский] took color photographs of everything he saw. He accomplished this by using RGB filters and obtaining 3 glass plate negatives, RGB respectively. To view the colored images, we need to align and overlap the three plates. To improve results, it is also a good idea to make adjustments such as cropping, contrasting, white balance, color mapping, etc. The process of reproducing the color image is to be automated in this project. </p>

<h2> Project Approach </h2>
<h3> Alignment </h3>
<p>
	In this project, we are given input files with channels in the order BGR (as opposed to the conventional RGB). For simplicity, I aligned G and R channels to the B channel. My general approach is to have a fixed channel size of height <i> h </i> and width <i> w </i>. Then, we use an algorithm to find the best coordinate for the left-upper corner of each channel to which I call <i> start </i>. </p>

<p><emphasis> 1. Basic Algorithm </emphasis></p>
<p>
	The first algorithm I adopted is to simply divide the image by three. So the <i> start </i> for BGR would be (0, 0), (h, 0) and (h*2, 0). Then stace them together using numpy.stack. This method gave pretty reliable results with low computation time.
</p>

<p><emphasis> 2. Better Algorithms </emphasis></p>
<p>
	I implemented both Sum of Squared Differences (SSD) and normalized cross-correlation (NCC) algorithms. I select a window that is smaller than the channel size to create sub-matrices for G and R channels. The sub-matrices are initialized to either 0 or infinity to suit the metric. This also help with handling out of bound windows.

<h2> Project Results </h2>

<h3> Example Results </h3>
<img src="./output/castle" alt="castle">
<img src="./output/cathedral" alt="cathedral">
<img src="./output/emir" alt="emir">
<img src="./output/harvesters" alt="harvesters">
<img src="./output/icon" alt="icon">
<img src="./output/lady" alt="lady">
<img src="./output/melons" alt="melons">
<img src="./output/monastery" alt="monastery">
<img src="./output/onion_church" alt="onion_church">
<img src="./output/self_portrait" alt="self_portrait">
<img src="./output/three_generations" alt="three_generations">
<img src="./output/tobolsk" alt="tobolsk">
<img src="./output/train" alt="train">
<img src="./output/workshop" alt="workshop">

<h4> Displacements </h4>
The offset for RGB was ...
<ul>
	<li>castle - "(0, 0), (2833, 0), (6082, 0)"</li>
	<li>cathedral - "(0, 0), (321, 0), (662, 0)"</li>
	<li>emir - "(0, 0), (2793, 0), (6002, 0)"</li>
	<li>harvesters - "(0, 0), (2790, 0), (6005, 0)"</li>
	<li>icon - "(0, 0), (2810, 0), (6042, 0)"</li>
	<li>lady - "(0, 0), (2789, 0), (5987, 0)"</li>
	<li>melons - "(0, 0), (2827, 0), (6067, 0)"</li>
	<li>monastery - "(0, 0), (321, 0), (662, 0)"</li>
	<li>onion_church - "(0, 0), (2802, 0), (6007, 0)"</li>
	<li>self_portrait - "(0, 0), (2826, 0), (6067, 0)"</li>
	<li>three_generations - "(0, 0), (2779, 0), (5979, 0)"</li>
	<li>tobolsk - "(0, 0), (321, 0), (662, 0)"</li>
	<li>train - "(0, 0), (2811, 0), (6032, 0)"</li>
	<li>workshop - "(0, 0), (2785, 0), (5977, 0)"</li>
</ul>

<h3> Extra Results </h3>
<img src="./output/church" alt="church">
<img src="./output/cotton" alt="cotton">
<img src="./output/kapri" alt="kapri">
<img src="./output/makhrovye" alt="makhrovye">

<h4> Displacements </h4>
The offset for BGR was ...
<ul>
	<li>church - "(0, 0), (2851, 0), (6114, 0)"</li>
	<li>cotton - "(0, 0), (2814, 0), (6040, 0)"</li>
	<li>kapri - "(0, 0), (321, 0), (662, 0)"</li>
	<li>makhrovye - "(0, 0), (321, 0), (662, 0)"</li>
</ul>

<h2> After Thoughts </h2>
<h3> Difficulties </h3>	
	Buliding from scratch is really fun, but the downside it that it takes time to learn about new Python packages and to present the project as a whole nicely.

	Since there are so many parameters, I struggled to come up with a set of standardized arguments to pass into my alignment algorithms. Initially I wanted everything to be adjustable, but it made it really hard to test results as well as the debugging followed. This contributed to not being able to align the channels as good as I wanted.

<h3> Wish List </h3>
	I would like to implement adjustments before and after alignment. Maybe having a few repeated iterations of adjust, align, re-adjust, re-align can help find the best displacement values.

	I would also like to experiment more on adjustments that can be made to make the results look better.
</body>
</html>